import QRCode from 'qrcodejs2-fixes';
import md5 from 'md5';

/**
 * @file: 二维码生成
 * @author: haoxin
 */
/**
 * 获取二维码canvas对象
 * @param {Object} config 二维码配置项
 * @return {Promise<Element>} HTMLCanvasElement 绘制了二维码的canvas对象
 */

const getQrCodeImg = config => {
  return new Promise((resolve, reject) => {
    const options = Object.assign({
      width: 70,
      height: 70,
      colorDark: '#000000',
      colorLight: '#ffffff',
      correctLevel: QRCode.CorrectLevel.L
    }, config, {
      text: ''
    });
    const qrWrap = document.createElement('div');
    const qrCode = new QRCode(qrWrap, options);
    qrCode.makeCode(config.text);
    const qrCodeCanvas = qrWrap.getElementsByTagName('canvas')[0];
    resolve(qrCodeCanvas);
  });
};

/**
 * @file: 工具函数
 * @author: haoxin
 */

/**
 * 判断客户端
 * @return {string} 宿主类型 ios | android | pc
 */
const clientType = () => {
  let client = '';

  if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) {
    client = 'ios';
  } else if (/(Android)/i.test(navigator.userAgent)) {
    client = 'android';
  } else {
    client = 'pc';
  }

  return client;
};
/**
 * JSON对象key值重命名
 * @param {Object} object 配置项
 * @param {string} key 键名
 * @param {string} newKey 新键名
 * @return {Object} key值重命名后的对象
 */

const renameKey = (object, key, newKey) => {
  const clonedObj = Object.assign({}, object);
  const targetKey = clonedObj[key];

  if (targetKey && newKey) {
    delete clonedObj[key];
    clonedObj[newKey] = targetKey;
  }

  return clonedObj;
};
/**
 * 根据某属性将对象数组进行分组
 * @param {Array} array 数组对象
 * @param {string} key 键名
 * @param {number} init 分组对象键名默认值
 * @return {Object} 返回已分组的对象
 */

const splitArr = (array, key, init) => {
  return array.reduce((acc, item) => {
    let currentVal = item[key] || init;
    acc[currentVal] || (acc[currentVal] = []);
    acc[currentVal].push(item);
    return acc;
  }, {});
};

/**
 * @file errorMap
 * @author haoxin
 */
const errorMap = {
  CREATE_CANVAS_ERROR: {
    errno: 10001,
    errmsg: '[mix img err] 创建canvas标签出错！'
  },
  ADD_BG_ERROR: {
    errno: 20001,
    errmsg: '[mix img err] 绘制背景图出错！'
  },
  ADD_DYNAMIC_ERROR: {
    errno: 30001,
    errmsg: '[mix img err] 添加动态元素错误！'
  },
  ADD_TEXT_ERROR: {
    errno: 300011,
    errmsg: '[mix img err] 添加文字错误！'
  },
  ADD_IMG_ERROR: {
    errno: 300012,
    errmsg: '[mix img err] 添加图片错误！'
  },
  ADD_QRCODE_ERROR: {
    errno: 30002,
    errmsg: '[mix img err] 添加二维码错误！'
  },
  TO_BASE64_ERROR: {
    errno: 40001,
    errmsg: '[mix img err] canvas转base64出错！'
  },
  CREATE_IMG_ERROR: {
    errno: 90001,
    errmsg: '[mix img err] 创建img标签出错！请排查该图片是否跨域'
  },
  CREATE_IMG_TIMEOUT: {
    errno: 90002,
    errmsg: '[mix img err] 创建img标签超时！'
  }
};

/**
 * 创建启用了CORS的图片
 * @param {string} src 图片的src
 * @param {number} timeout 请求图片的超时时间
 * @return {Promise<Element>} HTMLImageElement img对象
 */
const createImg = (src, timeout = 5000) => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = src;
    setTimeout(() => {
      reject(Object.assign({}, errorMap.CREATE_IMG_TIMEOUT, {
        err: `img response time more than ${timeout} ms`,
        errSrc: src
      }));
    }, timeout);

    img.onload = () => {
      resolve(img);
    };

    img.onerror = err => {
      reject(Object.assign({}, errorMap.CREATE_IMG_ERROR, {
        err,
        errSrc: src
      }));
    };
  });
};

/**
 * @file: 向canvas中增加元素
 * @author: haoxin
 */
/**
 * 变量替换
 * @param {string} text 带变量的原内容
 * @param {Object} replaceText 待替换的变量对象
 * @return {string} targetText 替换后的内容
 */

const replaceVariable = (text, replaceText = {}) => {
  const reg = /(.*)({(.*)})(.*)/g;
  const matchTextArr = reg.exec(text);
  return matchTextArr ? matchTextArr[1] + replaceText[matchTextArr[3]] + matchTextArr[4] : text;
};
/**
 * 向canvas中添加文本
 * @param {Object} ctx 上下文对象
 * @param {Object} config 文本配置
 * @param {number} config.position.x 距上距离
 * @param {number} config.position.y 距左距离
 * @param {string} config.style.color 颜色
 * @param {number} config.style.fontSize 大小
 * @param {string} config.style.fontWeight 粗细
 * @param {string} config.style.textAlign 水平对齐方式
 * @param {string} config.style.textBaseline 垂直对齐方式
 * @param {string} config.font 字体设置 优先级高于style中的配置
 * @param {Object} replaceText 替换项对象
 */

const addTextToCanvas = async (ctx, config = {}, replaceText) => {
  try {
    var _config$style, _config$style2, _config$style3, _config$style4, _config$style5, _config$style6, _config$position, _config$position2;

    if (!config.text) {
      return;
    } // 读取字体配置


    const fontSize = (_config$style = config.style) !== null && _config$style !== void 0 && _config$style.fontSize ? `${config.style.fontSize}px` : '20px';
    const fontWeight = (_config$style2 = config.style) !== null && _config$style2 !== void 0 && _config$style2.fontWeight ? `${config.style.fontWeight}` : 'normal';
    const initFF = clientType() === 'ios' ? 'PingFang SC' : 'Roboto';
    const fontFamily = (_config$style3 = config.style) !== null && _config$style3 !== void 0 && _config$style3.fontFamily ? `${config.style.fontFamily}, ${initFF}` : initFF;
    const font = config.font ? config.font : `${fontWeight} ${fontSize} ${fontFamily}`; // 等待字体加载完毕

    try {
      var _document, _document$fonts;

      ((_document = document) === null || _document === void 0 ? void 0 : (_document$fonts = _document.fonts) === null || _document$fonts === void 0 ? void 0 : _document$fonts.load) && (await document.fonts.load(font));
    } catch (e) {
      console.error('[Font loading failed]', e);
    } // 颜色


    ctx.fillStyle = (_config$style4 = config.style) === null || _config$style4 === void 0 ? void 0 : _config$style4.color; // 字体

    ctx.font = font; // 水平对齐

    ctx.textAlign = (_config$style5 = config.style) !== null && _config$style5 !== void 0 && _config$style5.textAlign ? config.style.textAlign : 'left'; // 垂直对齐

    ctx.textBaseline = (_config$style6 = config.style) !== null && _config$style6 !== void 0 && _config$style6.textBaseline ? config.style.textBaseline : 'alphabetic'; // 文本

    const text = replaceVariable(config.text, replaceText);
    ctx.fillText(text, ((_config$position = config.position) === null || _config$position === void 0 ? void 0 : _config$position.x) || 0, ((_config$position2 = config.position) === null || _config$position2 === void 0 ? void 0 : _config$position2.y) || 0);
  } catch (err) {
    return Promise.reject(Object.assign({}, errorMap.ADD_TEXT_ERROR, {
      err
    }));
  }
};
/**
 * 创建圆形裁剪区
 * @param {Object} ctx 上下文对象
 * @param {number} halfWidth 图形半宽
 * @param {number} halfHeight 图形半高
 * @param {number} x 图形距上距离
 * @param {number} y 图形距左距离
 */

const setClipZone = (ctx, halfWidth, halfHeight, x, y) => {
  ctx.beginPath();
  ctx.arc(halfWidth + x, halfHeight + y, halfWidth, 0, 2 * Math.PI);
  ctx.clip();
};
/**
 * 向canvas中添加图片
 * @param {Object} ctx 上下文对象
 * @param {Object} config 图片配置
 * @param {number} config.position.x 距上距离
 * @param {number} config.position.y 距左距离
 * @param {number} config.size.dWidth 图片宽
 * @param {number} config.size.dHeight 图片高
 * @param {number} config.isRound 是否裁剪为圆形
 * @param {Object} replaceText 替换项对象
 * @param {number} timeout 请求图片的超时时间
 */

const addImgToCanvas = async (ctx, config = {}, replaceText, timeout) => {
  try {
    var _config$position5, _config$position6;

    if (!config.imgUrl) {
      return;
    } // 传入图片为base64不进行变量替换


    const isBase64 = config.imgUrl.startsWith('data:image');
    const src = isBase64 ? config.imgUrl : replaceVariable(config.imgUrl, replaceText);
    const img = await createImg(src, timeout);
    let width = img.width;
    let height = img.height;

    if (config.size && config.size.dWidth && config.size.dHeight) {
      width = config.size.dWidth;
      height = config.size.dHeight;
    }

    ctx.save();

    if (config.isRound) {
      var _config$position3, _config$position4;

      setClipZone(ctx, width / 2, height / 2, (_config$position3 = config.position) === null || _config$position3 === void 0 ? void 0 : _config$position3.x, (_config$position4 = config.position) === null || _config$position4 === void 0 ? void 0 : _config$position4.y);
    }

    ctx.drawImage(img, (_config$position5 = config.position) === null || _config$position5 === void 0 ? void 0 : _config$position5.x, (_config$position6 = config.position) === null || _config$position6 === void 0 ? void 0 : _config$position6.y, width, height);
    ctx.restore();
  } catch (err) {
    return Promise.reject(Object.assign({}, errorMap.ADD_IMG_ERROR, {
      err
    }));
  }
};
/**
 * 向canvas中添加二维码
 * @param {Object} config 配置项
 * @return {Promise<Object>} config 配置项
 */

const addQrCodeToCanvas = async config => {
  try {
    var _qrCode;

    let {
      ctx,
      qrCode,
      replaceText
    } = config;

    if ((_qrCode = qrCode) !== null && _qrCode !== void 0 && _qrCode.text && qrCode.width && qrCode.height) {
      qrCode.text = replaceVariable(qrCode.text, replaceText);
      qrCode = renameKey(qrCode, 'foreground', 'colorDark');
      qrCode = renameKey(qrCode, 'background', 'colorLight');
      const qrCodeCanvas = await getQrCodeImg(qrCode);
      ctx.drawImage(qrCodeCanvas, qrCode.x || 0, qrCode.y || 0, qrCode.width, qrCode.height);
    }

    return config.base.dataType === 'canvas' ? {
      canvas: config.canvasImg
    } : config;
  } catch (err) {
    return Promise.reject(Object.assign({}, errorMap.ADD_QRCODE_ERROR, {
      err
    }));
  }
};
/**
 * 创建canvas标签
 * @param {Object} config 配置项
 * @return {Object} canvas对象、canvas上下文与配置项合并后的总配置项
 */

const createCanvas = config => {
  try {
    const canvasId = '_mixImgCanvas';
    const {
      width,
      height
    } = config.base;
    let canvas = document.getElementById(canvasId);

    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = canvasId;
    }

    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    return Object.assign({
      canvasImg: canvas,
      ctx
    }, config);
  } catch (err) {
    return Promise.reject(Object.assign({}, errorMap.CREATE_CANVAS_ERROR, {
      err
    }));
  }
};
/**
 * canvas转base64文件
 * @param {Object} canvas canvas对象
 * @param {Object} fileConfig 文件配置
 * @param {string} fileConfig.fileType 文件类型
 * @param {number} fileConfig.quality 文件质量 0-1
 * @return {string} base64图片的 data URI
 */

const canvasToBase64 = (canvas, fileConfig = {}) => {
  try {
    const fileType = fileConfig.fileType ? `image/${fileConfig.fileType}` : 'image/jpeg';
    const quality = fileConfig.quality || 0.8;
    return canvas.toDataURL(fileType, quality);
  } catch (err) {
    return Promise.reject(Object.assign({}, errorMap.TO_BASE64_ERROR, {
      err
    }));
  }
};

/**
 * @file: 图片合成方法
 * @author: haoxin
 */
let hash = '';
/**
 * 绘制背景图
 * @param {Object} config 总配置项
 * @return {Promise<Object>} config 总配置项
 */

const addBackgroundImg = async config => {
  try {
    const {
      base,
      ctx
    } = config;
    const width = base.width || 300;
    const height = base.height || 300;

    if (base.backgroundImg) {
      const img = await createImg(base.backgroundImg, base.loadingTimeout);
      ctx.drawImage(img, 0, 0, width, height);
    }

    return config;
  } catch (err) {
    return Promise.reject(Object.assign({}, errorMap.ADD_BG_ERROR, {
      err
    }));
  }
};
/**
 * 添加动态元素
 * @param {Object} config 总配置项
 * @return {Promise<Object>} config 总配置项
 */

const addDynamicElementToCanvas = async config => {
  try {
    const {
      ctx,
      dynamic = [],
      replaceText
    } = config;
    const timeout = config.base.loadingTimeout; // 动态配置按weight属性分组

    let weightConfig = splitArr(dynamic, 'weight', 0);
    let weightKeys = Object.keys(weightConfig);
    weightKeys.sort(function (a, b) {
      return a - b;
    }); // 分组绘制动态元素

    for (let item of weightKeys) {
      let dynamicPromises = [];
      let currWeightConfig = weightConfig[item];

      for (let i = 0; i < currWeightConfig.length; i++) {
        if (currWeightConfig[i].type === 1) {
          dynamicPromises.push(addImgToCanvas(ctx, currWeightConfig[i], replaceText, timeout));
        } else {
          dynamicPromises.push(addTextToCanvas(ctx, currWeightConfig[i], replaceText));
        }
      }

      await Promise.all(dynamicPromises);
    }

    return config;
  } catch (err) {
    return Promise.reject(Object.assign({}, errorMap.ADD_DYNAMIC_ERROR, {
      err
    }));
  }
};
/**
 * 缓存base64文件
 * @param {string} base64Img 图片base64字符
 */

const cacheFile = base64Img => {
  try {
    let base64Queue = JSON.parse(localStorage.getItem('mix_img_base64_queue')) || [];
    base64Queue.push(`mix_img_base64_${hash}`); // 缓存超过2个出队 && 删除对应的item

    if (base64Queue.length > 2) {
      localStorage.removeItem(base64Queue.shift());
    }

    localStorage.setItem('mix_img_base64_queue', JSON.stringify(base64Queue));
    localStorage.setItem(`mix_img_base64_${hash}`, base64Img);
  } catch (e) {
    console.log(`[mix img log] ${e}`);
  }
};
/**
 * 生成base64图片
 * @param {Object} config 总配置项
 * @return {Promise<Object>} base64字符对象
 */

const getBase64 = async config => {
  const {
    canvasImg,
    base,
    dev
  } = config;
  const base64Img = await canvasToBase64(canvasImg, {
    fileType: base.fileType,
    quality: base.quality
  });

  if (!(dev !== null && dev !== void 0 && dev.notUseCache)) {
    cacheFile(base64Img);
  }

  return {
    base64: base64Img
  };
};
/**
 * 获取canvas处理流程
 * @param {Object} config 总配置项
 * @return {Promise<Object>} base64字符对象
 */

const processCanvas = async config => {
  var _ref, _ref2, _ref3, _config;

  return _ref = (_ref2 = (_ref3 = (_config = config, await createCanvas(_config)), await addBackgroundImg(_ref3)), await addDynamicElementToCanvas(_ref2)), await addQrCodeToCanvas(_ref);
};
/**
 * 获取base64处理流程
 * @param {Object} config 总配置项
 * @return {Promise<Object>} canvas对象
 */

const processBase64 = async config => {
  var _config$dev, _ref4, _ref5, _ref6, _ref7, _config2;

  hash = md5(JSON.stringify(config));
  const localBase64Img = (_config$dev = config.dev) !== null && _config$dev !== void 0 && _config$dev.notUseCache ? '' : localStorage.getItem(`mix_img_base64_${hash}`); // 有缓存 直接读取 | 无缓存 重新获取

  return localBase64Img ? {
    base64: localBase64Img
  } : (_ref4 = (_ref5 = (_ref6 = (_ref7 = (_config2 = config, await createCanvas(_config2)), await addBackgroundImg(_ref7)), await addDynamicElementToCanvas(_ref6)), await addQrCodeToCanvas(_ref5)), await getBase64(_ref4));
};
/**
 * 图片合成函数
 * @param {Object} mixConfig
 * @param {string} mixConfig.base.dataType 合成类型  默认 'base64' 返回base64图片字符 | 'canvas' 返回canvas对象
 * @return {Promise<Object>} 合成结果
 */

const mixImg = async mixConfig => {
  const start = new Date().getTime();

  try {
    // 深拷贝配置项
    let config = JSON.parse(JSON.stringify(mixConfig));
    let data = config.base.dataType === 'canvas' ? await processCanvas(config) : await processBase64(config);
    console.log(`[mix img time] ${new Date().getTime() - start} ms`);
    return {
      errno: 0,
      data
    };
  } catch (err) {
    return err;
  }
};

export { addBackgroundImg, addDynamicElementToCanvas, cacheFile, getBase64, mixImg, processBase64, processCanvas };
